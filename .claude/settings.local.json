{
  "permissions": {
    "allow": [
      "Bash(tree -L 3 -a:*)",
      "Bash(find:*)",
      "Bash(chmod:*)",
      "Bash(cat:*)",
      "Bash(/mnt/e/PROJETOS/Consultor.AI/src/lib/whatsapp/webhook-validation.ts <<'ENDOFFILE'\n/**\n * WhatsApp Webhook Validation\n * Validates webhook signatures from Meta\n */\n\nimport { createHmac } from 'crypto'\n\n/**\n * Validates Meta webhook signature (HMAC SHA256)\n * \n * @param signature - X-Hub-Signature-256 header value\n * @param payload - Raw request body as string\n * @param appSecret - Meta App Secret\n * @returns True if signature is valid\n */\nexport function validateMetaSignature(\n  signature: string | null,\n  payload: string,\n  appSecret: string\n): boolean {\n  if (!signature) {\n    return false\n  }\n\n  try {\n    // Meta sends signature in format: sha256=<hash>\n    const signatureHash = signature.replace('sha256=', '')\n\n    // Calculate expected signature\n    const hmac = createHmac('sha256', appSecret)\n    const expectedHash = hmac.update(payload).digest('hex')\n\n    // Constant-time comparison to prevent timing attacks\n    return timingSafeEqual(\n      Buffer.from(signatureHash, 'hex'),\n      Buffer.from(expectedHash, 'hex')\n    )\n  } catch (error) {\n    console.error('Error validating webhook signature:', error)\n    return false\n  }\n}\n\n/**\n * Timing-safe comparison of two buffers\n */\nfunction timingSafeEqual(a: Buffer, b: Buffer): boolean {\n  if (a.length !== b.length) {\n    return false\n  }\n\n  let result = 0\n  for (let i = 0; i < a.length; i++) {\n    result |= a[i] ^ b[i]\n  }\n\n  return result === 0\n}\n\n/**\n * Extracts message from Meta webhook payload\n */\nexport interface ExtractedMessage {\n  messageId: string\n  from: string // Phone number\n  timestamp: string\n  type: 'text' | 'image' | 'audio' | 'video' | 'document' | 'location' | 'contacts'\n  text?: string\n  imageUrl?: string\n  audioUrl?: string\n  videoUrl?: string\n  documentUrl?: string\n  caption?: string\n}\n\nexport function extractMessageFromWebhook(payload: any): ExtractedMessage | null {\n  try {\n    const entry = payload.entry?.[0]\n    const changes = entry?.changes?.[0]\n    const value = changes?.value\n\n    if (!value?.messages || value.messages.length === 0) {\n      return null // Not a message event\n    }\n\n    const message = value.messages[0]\n\n    const extracted: ExtractedMessage = {\n      messageId: message.id,\n      from: message.from,\n      timestamp: message.timestamp,\n      type: message.type,\n    }\n\n    // Extract content based on type\n    switch (message.type) {\n      case 'text':\n        extracted.text = message.text?.body\n        break\n\n      case 'image':\n        extracted.imageUrl = message.image?.id // Will need to download later\n        extracted.caption = message.image?.caption\n        break\n\n      case 'audio':\n        extracted.audioUrl = message.audio?.id\n        break\n\n      case 'video':\n        extracted.videoUrl = message.video?.id\n        extracted.caption = message.video?.caption\n        break\n\n      case 'document':\n        extracted.documentUrl = message.document?.id\n        extracted.caption = message.document?.caption\n        break\n    }\n\n    return extracted\n  } catch (error) {\n    console.error('Error extracting message from webhook:', error)\n    return null\n  }\n}\n\n/**\n * Checks if webhook payload is a status update\n */\nexport function isStatusUpdate(payload: any): boolean {\n  const entry = payload.entry?.[0]\n  const changes = entry?.changes?.[0]\n  const value = changes?.value\n\n  return Boolean(value?.statuses && value.statuses.length > 0)\n}\n\n/**\n * Extracts status update from webhook\n */\nexport interface MessageStatus {\n  messageId: string\n  status: 'sent' | 'delivered' | 'read' | 'failed'\n  timestamp: string\n  recipientId: string\n  error?: {\n    code: number\n    title: string\n  }\n}\n\nexport function extractStatusFromWebhook(payload: any): MessageStatus | null {\n  try {\n    const entry = payload.entry?.[0]\n    const changes = entry?.changes?.[0]\n    const value = changes?.value\n\n    if (!value?.statuses || value.statuses.length === 0) {\n      return null\n    }\n\n    const status = value.statuses[0]\n\n    return {\n      messageId: status.id,\n      status: status.status,\n      timestamp: status.timestamp,\n      recipientId: status.recipient_id,\n      error: status.errors?.[0] ? {\n        code: status.errors[0].code,\n        title: status.errors[0].title,\n      } : undefined,\n    }\n  } catch (error) {\n    console.error('Error extracting status from webhook:', error)\n    return null\n  }\n}\nENDOFFILE)",
      "Bash(/mnt/e/PROJETOS/Consultor.AI/src/app/api/consultants/meta-callback/route.ts <<'ENDOFFILE'\n/**\n * Meta OAuth Callback API\n * Handles the OAuth callback from Meta Embedded Signup\n * Exchanges code for access token and saves integration\n */\n\nimport { NextRequest, NextResponse } from 'next/server'\nimport { createServerClient } from '@/lib/supabase/server'\nimport { encrypt } from '@/lib/encryption'\n\nexport async function POST(req: NextRequest) {\n  try {\n    const { code } = await req.json()\n\n    if (!code) {\n      return NextResponse.json(\n        { error: 'Missing authorization code' },\n        { status: 400 }\n      )\n    }\n\n    // Get authenticated user\n    const supabase = await createServerClient()\n    const { data: { user }, error: authError } = await supabase.auth.getUser()\n\n    if (authError || !user) {\n      return NextResponse.json(\n        { error: 'Unauthorized' },\n        { status: 401 }\n      )\n    }\n\n    // Exchange code for access token\n    const tokenResponse = await fetch(\n      `https://graph.facebook.com/v18.0/oauth/access_token?` +\n      `client_id=${process.env.NEXT_PUBLIC_META_APP_ID}&` +\n      `client_secret=${process.env.META_APP_SECRET}&` +\n      `code=${code}`\n    )\n\n    if (!tokenResponse.ok) {\n      const error = await tokenResponse.json()\n      console.error('Meta token exchange failed:', error)\n      return NextResponse.json(\n        { error: 'Failed to exchange authorization code' },\n        { status: 500 }\n      )\n    }\n\n    const { access_token } = await tokenResponse.json()\n\n    // Debug token to get WABA ID and permissions\n    const debugResponse = await fetch(\n      `https://graph.facebook.com/v18.0/debug_token?` +\n      `input_token=${access_token}&` +\n      `access_token=${process.env.META_APP_ACCESS_TOKEN}`\n    )\n\n    if (!debugResponse.ok) {\n      console.error('Token debug failed')\n      return NextResponse.json(\n        { error: 'Failed to validate access token' },\n        { status: 500 }\n      )\n    }\n\n    const debugData = await debugResponse.json()\n    const wabaId = debugData.data?.granular_scopes?.[0]?.target_ids?.[0]\n\n    if (!wabaId) {\n      return NextResponse.json(\n        { error: 'Could not find WhatsApp Business Account ID' },\n        { status: 500 }\n      )\n    }\n\n    // Get phone numbers associated with WABA\n    const phoneResponse = await fetch(\n      `https://graph.facebook.com/v18.0/${wabaId}/phone_numbers`,\n      {\n        headers: {\n          'Authorization': `Bearer ${access_token}`,\n        },\n      }\n    )\n\n    if (!phoneResponse.ok) {\n      console.error('Failed to get phone numbers')\n      return NextResponse.json(\n        { error: 'Failed to retrieve phone numbers' },\n        { status: 500 }\n      )\n    }\n\n    const { data: phoneNumbers } = await phoneResponse.json()\n\n    if (!phoneNumbers || phoneNumbers.length === 0) {\n      return NextResponse.json(\n        { error: 'No phone numbers found for this WhatsApp Business Account' },\n        { status: 400 }\n      )\n    }\n\n    // Use first phone number (user can add more later)\n    const primaryPhone = phoneNumbers[0]\n\n    // Encrypt access token before storing\n    const encryptedAccessToken = encrypt(access_token)\n\n    // Save integration to database\n    const { data: integration, error: dbError } = await supabase\n      .from('whatsapp_integrations')\n      .insert({\n        consultant_id: user.id,\n        provider: 'meta',\n        access_token: encryptedAccessToken,\n        waba_id: wabaId,\n        phone_number_id: primaryPhone.id,\n        phone_number: primaryPhone.display_phone_number,\n        business_name: primaryPhone.verified_name,\n        display_name: primaryPhone.verified_name,\n        quality_rating: primaryPhone.quality_rating || 'UNKNOWN',\n        status: 'active',\n        verified_at: new Date().toISOString(),\n      })\n      .select()\n      .single()\n\n    if (dbError) {\n      console.error('Database error:', dbError)\n      return NextResponse.json(\n        { error: 'Failed to save integration: ' + dbError.message },\n        { status: 500 }\n      )\n    }\n\n    // TODO: Register webhook with Meta\n    // This would be done here, but requires deployed endpoint\n    // For now, webhook must be configured manually in Meta dashboard\n\n    // Return success with integration details\n    return NextResponse.json({\n      success: true,\n      integration: {\n        id: integration.id,\n        phoneNumber: primaryPhone.display_phone_number,\n        businessName: primaryPhone.verified_name,\n        qualityRating: primaryPhone.quality_rating,\n        status: 'active',\n      },\n    })\n  } catch (error) {\n    console.error('Meta callback error:', error)\n    return NextResponse.json(\n      { error: 'Internal server error' },\n      { status: 500 }\n    )\n  }\n}\nENDOFFILE)",
      "Bash(/mnt/e/PROJETOS/Consultor.AI/src/app/api/consultants/meta-callback/route.ts <<'ENDOFFILE'\n/**\n * Meta OAuth Callback API\n * Handles the OAuth callback from Meta Embedded Signup\n */\n\nimport { NextRequest, NextResponse } from 'next/server'\nimport { createServerClient } from '@/lib/supabase/server'\nimport { encrypt } from '@/lib/encryption'\n\nexport async function POST(req: NextRequest) {\n  try {\n    const { code } = await req.json()\n\n    if (!code) {\n      return NextResponse.json({ error: 'Missing code' }, { status: 400 })\n    }\n\n    const supabase = await createServerClient()\n    const { data: { user } } = await supabase.auth.getUser()\n\n    if (!user) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    // Exchange code for access token\n    const tokenRes = await fetch(\n      `https://graph.facebook.com/v18.0/oauth/access_token?` +\n      `client_id=${process.env.NEXT_PUBLIC_META_APP_ID}&` +\n      `client_secret=${process.env.META_APP_SECRET}&code=${code}`\n    )\n\n    const { access_token } = await tokenRes.json()\n\n    // Get WABA info\n    const debugRes = await fetch(\n      `https://graph.facebook.com/v18.0/debug_token?` +\n      `input_token=${access_token}&access_token=${process.env.META_APP_ACCESS_TOKEN}`\n    )\n\n    const debugData = await debugRes.json()\n    const wabaId = debugData.data?.granular_scopes?.[0]?.target_ids?.[0]\n\n    // Get phone numbers\n    const phoneRes = await fetch(\n      `https://graph.facebook.com/v18.0/${wabaId}/phone_numbers`,\n      { headers: { 'Authorization': `Bearer ${access_token}` } }\n    )\n\n    const { data: phones } = await phoneRes.json()\n    const phone = phones[0]\n\n    // Save to database\n    const { data: integration } = await supabase\n      .from('whatsapp_integrations')\n      .insert({\n        consultant_id: user.id,\n        provider: 'meta',\n        access_token: encrypt(access_token),\n        waba_id: wabaId,\n        phone_number_id: phone.id,\n        phone_number: phone.display_phone_number,\n        business_name: phone.verified_name,\n        quality_rating: phone.quality_rating,\n        status: 'active',\n        verified_at: new Date().toISOString(),\n      })\n      .select()\n      .single()\n\n    return NextResponse.json({\n      success: true,\n      integration: {\n        phoneNumber: phone.display_phone_number,\n        businessName: phone.verified_name,\n      },\n    })\n  } catch (error) {\n    console.error('Meta callback error:', error)\n    return NextResponse.json({ error: 'Server error' }, { status: 500 })\n  }\n}\nENDOFFILE)",
      "Bash(/mnt/e/PROJETOS/Consultor.AI/Dockerfile <<'ENDOFFILE'\n# ==================================\n# Consultor.AI - Production Dockerfile\n# ==================================\n\n# Stage 1: Dependencies\nFROM node:20-alpine AS deps\nWORKDIR /app\n\n# Install dependencies based on lock file\nCOPY package.json package-lock.json ./\nRUN npm ci --only=production && \\\n    npm cache clean --force\n\n# Stage 2: Builder\nFROM node:20-alpine AS builder\nWORKDIR /app\n\n# Copy dependencies\nCOPY --from=deps /app/node_modules ./node_modules\nCOPY . .\n\n# Set environment for build\nENV NEXT_TELEMETRY_DISABLED=1\nENV NODE_ENV=production\n\n# Build Next.js app\nRUN npm run build\n\n# Stage 3: Runner\nFROM node:20-alpine AS runner\nWORKDIR /app\n\nENV NODE_ENV=production\nENV NEXT_TELEMETRY_DISABLED=1\n\n# Create non-root user\nRUN addgroup --system --gid 1001 nodejs && \\\n    adduser --system --uid 1001 nextjs\n\n# Copy necessary files\nCOPY --from=builder /app/public ./public\nCOPY --from=builder /app/.next/standalone ./\nCOPY --from=builder /app/.next/static ./.next/static\n\n# Set correct permissions\nRUN chown -R nextjs:nodejs /app\n\nUSER nextjs\n\nEXPOSE 3000\n\nENV PORT=3000\nENV HOSTNAME=\"0.0.0.0\"\n\n# Health check\nHEALTHCHECK --interval=30s --timeout=3s --start-period=40s --retries=3 \\\n  CMD node -e \"require('http').get('http://localhost:3000/api/health', (r) => {process.exit(r.statusCode === 200 ? 0 : 1)})\"\n\nCMD [\"node\", \"server.js\"]\nENDOFFILE)",
      "Bash(/mnt/e/PROJETOS/Consultor.AI/Dockerfile.dev <<'ENDOFFILE'\n# ==================================\n# Consultor.AI - Development Dockerfile\n# ==================================\n\nFROM node:20-alpine\n\nWORKDIR /app\n\n# Install dependencies\nCOPY package.json package-lock.json ./\nRUN npm install\n\n# Copy source code\nCOPY . .\n\n# Expose ports\nEXPOSE 3000\n\n# Development command with hot reload\nCMD [\"npm\", \"run\", \"dev\"]\nENDOFFILE)",
      "Bash(/mnt/e/PROJETOS/Consultor.AI/docker-compose.yml <<'ENDOFFILE'\n# ==================================\n# Consultor.AI - Docker Compose (Production/Staging)\n# ==================================\n\nversion: '3.8'\n\nservices:\n  # ----------------------------------\n  # Next.js Application\n  # ----------------------------------\n  app:\n    build:\n      context: .\n      dockerfile: Dockerfile\n    container_name: consultorai-app\n    restart: unless-stopped\n    ports:\n      - \"3000:3000\"\n    environment:\n      - NODE_ENV=production\n      - NEXT_PUBLIC_APP_URL=${NEXT_PUBLIC_APP_URL:-http://localhost:3000}\n      \n      # Supabase\n      - NEXT_PUBLIC_SUPABASE_URL=${NEXT_PUBLIC_SUPABASE_URL}\n      - NEXT_PUBLIC_SUPABASE_ANON_KEY=${NEXT_PUBLIC_SUPABASE_ANON_KEY}\n      - SUPABASE_SERVICE_ROLE_KEY=${SUPABASE_SERVICE_ROLE_KEY}\n      \n      # Google AI\n      - GOOGLE_AI_API_KEY=${GOOGLE_AI_API_KEY}\n      - GOOGLE_AI_MODEL=${GOOGLE_AI_MODEL:-gemini-1.5-flash}\n      \n      # Meta WhatsApp\n      - NEXT_PUBLIC_META_APP_ID=${NEXT_PUBLIC_META_APP_ID}\n      - META_APP_SECRET=${META_APP_SECRET}\n      - META_APP_ACCESS_TOKEN=${META_APP_ACCESS_TOKEN}\n      - NEXT_PUBLIC_META_CONFIG_ID=${NEXT_PUBLIC_META_CONFIG_ID}\n      - META_WEBHOOK_VERIFY_TOKEN=${META_WEBHOOK_VERIFY_TOKEN}\n      \n      # Encryption\n      - ENCRYPTION_KEY=${ENCRYPTION_KEY}\n      \n      # Redis\n      - REDIS_URL=redis://redis:6379\n      - REDIS_PASSWORD=${REDIS_PASSWORD:-consultorai_password}\n    depends_on:\n      redis:\n        condition: service_healthy\n    networks:\n      - consultorai-network\n    healthcheck:\n      test: [\"CMD\", \"node\", \"-e\", \"require('http').get('http://localhost:3000/api/health', (r) => {process.exit(r.statusCode === 200 ? 0 : 1)})\"]\n      interval: 30s\n      timeout: 3s\n      retries: 3\n      start_period: 40s\n\n  # ----------------------------------\n  # Redis\n  # ----------------------------------\n  redis:\n    image: redis:7-alpine\n    container_name: consultorai-redis\n    restart: unless-stopped\n    command: redis-server --requirepass ${REDIS_PASSWORD:-consultorai_password} --appendonly yes\n    ports:\n      - \"6379:6379\"\n    volumes:\n      - redis-data:/data\n    networks:\n      - consultorai-network\n    healthcheck:\n      test: [\"CMD\", \"redis-cli\", \"--raw\", \"incr\", \"ping\"]\n      interval: 10s\n      timeout: 5s\n      retries: 3\n\n  # ----------------------------------\n  # PostgreSQL (Optional - use if not using Supabase Cloud)\n  # ----------------------------------\n  # postgres:\n  #   image: postgres:15-alpine\n  #   container_name: consultorai-postgres\n  #   restart: unless-stopped\n  #   environment:\n  #     POSTGRES_DB: consultorai\n  #     POSTGRES_USER: postgres\n  #     POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-postgres}\n  #   ports:\n  #     - \"5432:5432\"\n  #   volumes:\n  #     - postgres-data:/var/lib/postgresql/data\n  #   networks:\n  #     - consultorai-network\n  #   healthcheck:\n  #     test: [\"CMD-SHELL\", \"pg_isready -U postgres\"]\n  #     interval: 10s\n  #     timeout: 5s\n  #     retries: 5\n\n  # ----------------------------------\n  # Nginx (Reverse Proxy - Optional)\n  # ----------------------------------\n  # nginx:\n  #   image: nginx:alpine\n  #   container_name: consultorai-nginx\n  #   restart: unless-stopped\n  #   ports:\n  #     - \"80:80\"\n  #     - \"443:443\"\n  #   volumes:\n  #     - ./deployment/nginx/nginx.conf:/etc/nginx/nginx.conf:ro\n  #     - ./deployment/nginx/ssl:/etc/nginx/ssl:ro\n  #   depends_on:\n  #     - app\n  #   networks:\n  #     - consultorai-network\n\nvolumes:\n  redis-data:\n    driver: local\n  # postgres-data:\n  #   driver: local\n\nnetworks:\n  consultorai-network:\n    driver: bridge\n    name: consultorai-prod\nENDOFFILE)"
    ]
  }
}
